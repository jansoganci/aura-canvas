{
  "version": 3,
  "sources": ["../../../lib/cors.ts", "../../../node_modules/nanoid/url-alphabet/index.js", "../../../node_modules/nanoid/index.browser.js", "../../../lib/db.ts", "../../../routes/session.ts", "../../../lib/r2.ts", "../../../routes/aura.ts", "../../../index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-a1UsWK/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-a1UsWK/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/.wrangler/tmp/dev-6Lh3di",
  "sourcesContent": ["// CORS configuration for cross-origin requests\n\nexport const corsHeaders = {\n  'Access-Control-Allow-Origin': '*', // Will be set dynamically\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n  'Access-Control-Allow-Credentials': 'true',\n  'Access-Control-Max-Age': '86400',\n};\n\nexport function getCorsHeaders(origin: string | null, allowedOrigins: string[]): HeadersInit {\n  const isAllowed = origin && (\n    allowedOrigins.includes(origin) ||\n    allowedOrigins.includes('*') ||\n    origin.includes('localhost') ||\n    origin.includes('pages.dev')\n  );\n\n  return {\n    ...corsHeaders,\n    'Access-Control-Allow-Origin': isAllowed ? origin : allowedOrigins[0],\n  };\n}\n\nexport function handleOptions(origin: string | null, allowedOrigins: string[]): Response {\n  return new Response(null, {\n    status: 204,\n    headers: getCorsHeaders(origin, allowedOrigins),\n  });\n}\n\nexport function jsonResponse(\n  data: unknown,\n  origin: string | null,\n  allowedOrigins: string[],\n  status = 200\n): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n      ...getCorsHeaders(origin, allowedOrigins),\n    },\n  });\n}\n\nexport function errorResponse(\n  message: string,\n  origin: string | null,\n  allowedOrigins: string[],\n  status = 400\n): Response {\n  return jsonResponse({ error: message }, origin, allowedOrigins, status);\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "// D1 Database helpers\n\nimport { nanoid } from 'nanoid';\n\nexport interface Session {\n  id: string;\n  session_token: string;\n  credits: number;\n  created_at: string;\n}\n\nexport interface Aura {\n  id: string;\n  session_id: string;\n  image_url: string;\n  aura_color: string | null;\n  aura_description: string | null;\n  personality_answers: string | null;\n  created_at: string;\n}\n\nexport interface Vote {\n  id: string;\n  aura_id: string;\n  visitor_id: string;\n  color: string;\n  created_at: string;\n}\n\nexport interface Purchase {\n  id: string;\n  session_id: string;\n  credits: number;\n  amount_cents: number;\n  stripe_payment_id: string | null;\n  status: string;\n  created_at: string;\n}\n\n// Session operations\nexport async function createSession(db: D1Database): Promise<Session> {\n  const id = nanoid();\n  const sessionToken = nanoid(32);\n\n  await db.prepare(\n    'INSERT INTO sessions (id, session_token, credits) VALUES (?, ?, 1)'\n  ).bind(id, sessionToken).run();\n\n  const session = await db.prepare(\n    'SELECT * FROM sessions WHERE id = ?'\n  ).bind(id).first<Session>();\n\n  return session!;\n}\n\nexport async function getSessionByToken(db: D1Database, token: string): Promise<Session | null> {\n  return db.prepare(\n    'SELECT * FROM sessions WHERE session_token = ?'\n  ).bind(token).first<Session>();\n}\n\nexport async function updateCredits(db: D1Database, sessionId: string, credits: number): Promise<void> {\n  await db.prepare(\n    'UPDATE sessions SET credits = ? WHERE id = ?'\n  ).bind(credits, sessionId).run();\n}\n\n// Aura operations\nexport async function createAura(\n  db: D1Database,\n  sessionId: string,\n  imageUrl: string,\n  auraColor: string,\n  auraDescription: string,\n  personalityAnswers: Record<string, string>\n): Promise<Aura> {\n  const id = nanoid();\n\n  await db.prepare(\n    'INSERT INTO auras (id, session_id, image_url, aura_color, aura_description, personality_answers) VALUES (?, ?, ?, ?, ?, ?)'\n  ).bind(id, sessionId, imageUrl, auraColor, auraDescription, JSON.stringify(personalityAnswers)).run();\n\n  const aura = await db.prepare(\n    'SELECT * FROM auras WHERE id = ?'\n  ).bind(id).first<Aura>();\n\n  return aura!;\n}\n\nexport async function getAuraById(db: D1Database, id: string): Promise<Aura | null> {\n  return db.prepare(\n    'SELECT * FROM auras WHERE id = ?'\n  ).bind(id).first<Aura>();\n}\n\nexport async function getAurasBySession(db: D1Database, sessionId: string): Promise<Aura[]> {\n  const result = await db.prepare(\n    'SELECT * FROM auras WHERE session_id = ? ORDER BY created_at DESC'\n  ).bind(sessionId).all<Aura>();\n\n  return result.results;\n}\n\n// Vote operations\nexport async function createVote(\n  db: D1Database,\n  auraId: string,\n  visitorId: string,\n  color: string\n): Promise<Vote> {\n  const id = nanoid();\n\n  // Upsert - update if exists, insert if not\n  await db.prepare(`\n    INSERT INTO votes (id, aura_id, visitor_id, color)\n    VALUES (?, ?, ?, ?)\n    ON CONFLICT(aura_id, visitor_id) DO UPDATE SET color = excluded.color\n  `).bind(id, auraId, visitorId, color).run();\n\n  const vote = await db.prepare(\n    'SELECT * FROM votes WHERE aura_id = ? AND visitor_id = ?'\n  ).bind(auraId, visitorId).first<Vote>();\n\n  return vote!;\n}\n\nexport async function getVotesByAura(db: D1Database, auraId: string): Promise<Vote[]> {\n  const result = await db.prepare(\n    'SELECT * FROM votes WHERE aura_id = ?'\n  ).bind(auraId).all<Vote>();\n\n  return result.results;\n}\n\nexport async function getVoteByVisitor(\n  db: D1Database,\n  auraId: string,\n  visitorId: string\n): Promise<Vote | null> {\n  return db.prepare(\n    'SELECT * FROM votes WHERE aura_id = ? AND visitor_id = ?'\n  ).bind(auraId, visitorId).first<Vote>();\n}\n\n// Purchase operations\nexport async function createPurchase(\n  db: D1Database,\n  sessionId: string,\n  credits: number,\n  amountCents: number\n): Promise<Purchase> {\n  const id = nanoid();\n\n  await db.prepare(\n    'INSERT INTO purchases (id, session_id, credits, amount_cents) VALUES (?, ?, ?, ?)'\n  ).bind(id, sessionId, credits, amountCents).run();\n\n  const purchase = await db.prepare(\n    'SELECT * FROM purchases WHERE id = ?'\n  ).bind(id).first<Purchase>();\n\n  return purchase!;\n}\n\nexport async function updatePurchaseStatus(\n  db: D1Database,\n  purchaseId: string,\n  status: string,\n  stripePaymentId?: string\n): Promise<void> {\n  if (stripePaymentId) {\n    await db.prepare(\n      'UPDATE purchases SET status = ?, stripe_payment_id = ? WHERE id = ?'\n    ).bind(status, stripePaymentId, purchaseId).run();\n  } else {\n    await db.prepare(\n      'UPDATE purchases SET status = ? WHERE id = ?'\n    ).bind(status, purchaseId).run();\n  }\n}\n", "// Session management routes\n\nimport { createSession, getSessionByToken } from '../lib/db';\nimport { jsonResponse, errorResponse } from '../lib/cors';\n\nexport interface Env {\n  DB: D1Database;\n  APP_URL: string;\n}\n\nexport async function handleSession(\n  request: Request,\n  env: Env,\n  origin: string | null,\n  allowedOrigins: string[]\n): Promise<Response> {\n  const method = request.method;\n\n  if (method === 'POST') {\n    return handleCreateSession(request, env, origin, allowedOrigins);\n  }\n\n  if (method === 'GET') {\n    return handleGetSession(request, env, origin, allowedOrigins);\n  }\n\n  return errorResponse('Method not allowed', origin, allowedOrigins, 405);\n}\n\nasync function handleCreateSession(\n  request: Request,\n  env: Env,\n  origin: string | null,\n  allowedOrigins: string[]\n): Promise<Response> {\n  try {\n    const session = await createSession(env.DB);\n\n    const response = jsonResponse({\n      session: {\n        id: session.id,\n        credits: session.credits,\n        createdAt: session.created_at,\n      },\n    }, origin, allowedOrigins);\n\n    // Set session cookie\n    response.headers.append(\n      'Set-Cookie',\n      `aura_session=${session.session_token}; Path=/; HttpOnly; SameSite=None; Secure; Max-Age=31536000`\n    );\n\n    return response;\n  } catch (error) {\n    console.error('Error creating session:', error);\n    return errorResponse('Failed to create session', origin, allowedOrigins, 500);\n  }\n}\n\nasync function handleGetSession(\n  request: Request,\n  env: Env,\n  origin: string | null,\n  allowedOrigins: string[]\n): Promise<Response> {\n  try {\n    // Get session token from cookie\n    const cookieHeader = request.headers.get('Cookie') || '';\n    const cookies = Object.fromEntries(\n      cookieHeader.split(';').map(c => {\n        const [key, ...vals] = c.trim().split('=');\n        return [key, vals.join('=')];\n      })\n    );\n\n    const sessionToken = cookies['aura_session'];\n\n    if (!sessionToken) {\n      return jsonResponse({ session: null }, origin, allowedOrigins);\n    }\n\n    const session = await getSessionByToken(env.DB, sessionToken);\n\n    if (!session) {\n      return jsonResponse({ session: null }, origin, allowedOrigins);\n    }\n\n    return jsonResponse({\n      session: {\n        id: session.id,\n        credits: session.credits,\n        createdAt: session.created_at,\n      },\n    }, origin, allowedOrigins);\n  } catch (error) {\n    console.error('Error getting session:', error);\n    return errorResponse('Failed to get session', origin, allowedOrigins, 500);\n  }\n}\n", "// R2 Storage helpers\n\nexport async function uploadImage(\n  r2: R2Bucket,\n  key: string,\n  data: ArrayBuffer,\n  contentType: string\n): Promise<void> {\n  await r2.put(key, data, {\n    httpMetadata: {\n      contentType,\n      cacheControl: 'public, max-age=31536000', // 1 year cache\n    },\n  });\n}\n\nexport async function getImage(r2: R2Bucket, key: string): Promise<R2ObjectBody | null> {\n  return r2.get(key);\n}\n\nexport async function deleteImage(r2: R2Bucket, key: string): Promise<void> {\n  await r2.delete(key);\n}\n\nexport function getPublicUrl(bucketUrl: string, key: string): string {\n  return `${bucketUrl}/${key}`;\n}\n\n// Parse base64 data URL to buffer\nexport function parseBase64Image(dataUrl: string): { buffer: ArrayBuffer; contentType: string } {\n  const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);\n\n  if (!matches) {\n    throw new Error('Invalid base64 image format');\n  }\n\n  const contentType = matches[1];\n  const base64Data = matches[2];\n\n  // Convert base64 to ArrayBuffer\n  const binaryString = atob(base64Data);\n  const bytes = new Uint8Array(binaryString.length);\n\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  return {\n    buffer: bytes.buffer,\n    contentType,\n  };\n}\n", "// Aura routes\n\nimport { nanoid } from 'nanoid';\nimport {\n  createAura,\n  getAuraById,\n  getSessionByToken,\n  updateCredits,\n} from '../lib/db';\nimport { uploadImage, parseBase64Image } from '../lib/r2';\nimport { jsonResponse, errorResponse } from '../lib/cors';\n\nexport interface Env {\n  DB: D1Database;\n  IMAGES: R2Bucket;\n  APP_URL: string;\n  GEMINI_API_KEY: string;\n}\n\n// Gemini API response types\ninterface GeminiResponse {\n  candidates: Array<{\n    content: {\n      parts: Array<{\n        text: string;\n      }>;\n    };\n  }>;\n}\n\ninterface AuraResult {\n  color: string;\n  description: string;\n}\n\n// Call Gemini Vision API to analyze the image\nasync function analyzeAuraWithGemini(\n  imageBase64: string,\n  energy: string,\n  element: string,\n  apiKey: string\n): Promise<AuraResult> {\n  const prompt = `You are an aura reader. Analyze this person's photo and determine their aura color.\n\nThe person described their energy as: ${energy}\nThe person chose this element: ${element}\n\nBased on the photo and these inputs, determine which aura color best fits this person.\n\nAvailable colors: RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE, PINK, WHITE\n\nMeanings:\n- RED: Passion, Energy, Drive, Leadership\n- ORANGE: Creativity, Joy, Enthusiasm, Adventure\n- YELLOW: Optimism, Intellect, Happiness, Confidence\n- GREEN: Growth, Healing, Balance, Compassion\n- BLUE: Peace, Calm, Communication, Intuition\n- PURPLE: Spirituality, Wisdom, Creativity, Mysticism\n- PINK: Love, Tenderness, Affection, Empathy\n- WHITE: Purity, Clarity, New beginnings, Spiritual awakening\n\nRespond with ONLY valid JSON in this exact format:\n{\"color\": \"COLOR_NAME\", \"description\": \"A 1-2 sentence personalized description about this person's aura energy.\"}\n\nMake the description fun, personal, and slightly mystical but relatable. Keep it short and punchy.`;\n\n  // Remove data URL prefix if present\n  const base64Data = imageBase64.replace(/^data:image\\/[a-z]+;base64,/, '');\n\n  const response = await fetch(\n    `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        contents: [\n          {\n            parts: [\n              {\n                inline_data: {\n                  mime_type: 'image/jpeg',\n                  data: base64Data,\n                },\n              },\n              {\n                text: prompt,\n              },\n            ],\n          },\n        ],\n        generationConfig: {\n          temperature: 0.7,\n          maxOutputTokens: 256,\n        },\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    console.error('Gemini API error:', await response.text());\n    throw new Error('Failed to analyze image');\n  }\n\n  const data = await response.json() as GeminiResponse;\n  const text = data.candidates?.[0]?.content?.parts?.[0]?.text;\n\n  if (!text) {\n    throw new Error('No response from Gemini');\n  }\n\n  // Parse JSON from response (handle potential markdown code blocks)\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n  if (!jsonMatch) {\n    throw new Error('Invalid response format');\n  }\n\n  const result = JSON.parse(jsonMatch[0]) as AuraResult;\n\n  // Validate color\n  const validColors = ['RED', 'ORANGE', 'YELLOW', 'GREEN', 'BLUE', 'PURPLE', 'PINK', 'WHITE'];\n  if (!validColors.includes(result.color)) {\n    result.color = 'PURPLE'; // Default fallback\n  }\n\n  return result;\n}\n\n// New: Analyze only (no storage)\nexport async function analyzeAura(\n  request: Request,\n  env: Env,\n  origin: string | null,\n  allowedOrigins: string[]\n): Promise<Response> {\n  try {\n    const body = await request.json() as {\n      imageData: string;\n      energy: string;\n      element: string;\n    };\n\n    if (!body.imageData) {\n      return errorResponse('Image data required', origin, allowedOrigins, 400);\n    }\n\n    // Analyze with Gemini AI\n    let auraResult: AuraResult;\n    try {\n      auraResult = await analyzeAuraWithGemini(\n        body.imageData,\n        body.energy || 'Good',\n        body.element || 'Energy',\n        env.GEMINI_API_KEY\n      );\n    } catch (error) {\n      console.error('Gemini analysis failed:', error);\n      // Fallback if AI fails\n      auraResult = {\n        color: 'PURPLE',\n        description: 'A unique and vibrant soul with endless potential.',\n      };\n    }\n\n    return jsonResponse({\n      color: auraResult.color,\n      description: auraResult.description,\n    }, origin, allowedOrigins);\n  } catch (error) {\n    console.error('Error analyzing aura:', error);\n    return errorResponse('Failed to analyze aura', origin, allowedOrigins, 500);\n  }\n}\n\nexport async function handleAura(\n  request: Request,\n  env: Env,\n  origin: string | null,\n  allowedOrigins: string[],\n  auraId?: string\n): Promise<Response> {\n  const method = request.method;\n\n  if (method === 'POST' && !auraId) {\n    return handleCreateAura(request, env, origin, allowedOrigins);\n  }\n\n  if (method === 'GET' && auraId) {\n    return handleGetAura(request, env, origin, allowedOrigins, auraId);\n  }\n\n  return errorResponse('Method not allowed', origin, allowedOrigins, 405);\n}\n\nasync function handleCreateAura(\n  request: Request,\n  env: Env,\n  origin: string | null,\n  allowedOrigins: string[]\n): Promise<Response> {\n  try {\n    // Get session from cookie\n    const cookieHeader = request.headers.get('Cookie') || '';\n    const cookies = Object.fromEntries(\n      cookieHeader.split(';').map(c => {\n        const [key, ...vals] = c.trim().split('=');\n        return [key, vals.join('=')];\n      })\n    );\n\n    const sessionToken = cookies['aura_session'];\n    if (!sessionToken) {\n      return errorResponse('No session found', origin, allowedOrigins, 401);\n    }\n\n    const session = await getSessionByToken(env.DB, sessionToken);\n    if (!session) {\n      return errorResponse('Invalid session', origin, allowedOrigins, 401);\n    }\n\n    // Check credits\n    if (session.credits < 1) {\n      return errorResponse('No credits remaining', origin, allowedOrigins, 402);\n    }\n\n    // Parse request body\n    const body = await request.json() as {\n      imageData: string;\n      personalityAnswers: Record<string, string>;\n    };\n\n    if (!body.imageData) {\n      return errorResponse('Image data required', origin, allowedOrigins, 400);\n    }\n\n    const energy = body.personalityAnswers?.energy || 'Good';\n    const element = body.personalityAnswers?.element || 'Energy';\n\n    // Analyze with Gemini AI\n    let auraResult: AuraResult;\n    try {\n      auraResult = await analyzeAuraWithGemini(\n        body.imageData,\n        energy,\n        element,\n        env.GEMINI_API_KEY\n      );\n    } catch (error) {\n      console.error('Gemini analysis failed:', error);\n      // Fallback if AI fails\n      auraResult = {\n        color: 'PURPLE',\n        description: 'A unique and vibrant soul with endless potential.',\n      };\n    }\n\n    // Upload image to R2\n    const imageKey = `auras/${nanoid()}.jpg`;\n    const { buffer, contentType } = parseBase64Image(body.imageData);\n    await uploadImage(env.IMAGES, imageKey, buffer, contentType);\n\n    // Create aura record\n    const aura = await createAura(\n      env.DB,\n      session.id,\n      imageKey,\n      auraResult.color,\n      auraResult.description,\n      body.personalityAnswers || {}\n    );\n\n    // Deduct credit\n    await updateCredits(env.DB, session.id, session.credits - 1);\n\n    return jsonResponse({\n      aura: {\n        id: aura.id,\n        imageUrl: aura.image_url,\n        auraColor: aura.aura_color,\n        auraDescription: aura.aura_description,\n        createdAt: aura.created_at,\n      },\n      credits: session.credits - 1,\n    }, origin, allowedOrigins);\n  } catch (error) {\n    console.error('Error creating aura:', error);\n    return errorResponse('Failed to create aura', origin, allowedOrigins, 500);\n  }\n}\n\nasync function handleGetAura(\n  request: Request,\n  env: Env,\n  origin: string | null,\n  allowedOrigins: string[],\n  auraId: string\n): Promise<Response> {\n  try {\n    const aura = await getAuraById(env.DB, auraId);\n\n    if (!aura) {\n      return errorResponse('Aura not found', origin, allowedOrigins, 404);\n    }\n\n    return jsonResponse({\n      aura: {\n        id: aura.id,\n        imageUrl: aura.image_url,\n        auraColor: aura.aura_color,\n        auraDescription: aura.aura_description,\n        personalityAnswers: aura.personality_answers ? JSON.parse(aura.personality_answers) : {},\n        createdAt: aura.created_at,\n      },\n    }, origin, allowedOrigins);\n  } catch (error) {\n    console.error('Error getting aura:', error);\n    return errorResponse('Failed to get aura', origin, allowedOrigins, 500);\n  }\n}\n", "// Main Worker API Router\n\nimport { handleOptions, errorResponse, jsonResponse } from './lib/cors';\nimport { handleSession } from './routes/session';\nimport { handleAura, analyzeAura } from './routes/aura';\n\nexport interface Env {\n  DB: D1Database;\n  IMAGES: R2Bucket;\n  APP_URL: string;\n  GEMINI_API_KEY: string;\n  STRIPE_SECRET_KEY: string;\n  STRIPE_WEBHOOK_SECRET: string;\n}\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    const path = url.pathname;\n    const method = request.method;\n    const origin = request.headers.get('Origin');\n\n    // Allowed origins for CORS\n    const allowedOrigins = [\n      env.APP_URL,\n      'http://localhost:3000',\n      'https://aura-canvas.pages.dev',\n    ];\n\n    // Handle CORS preflight\n    if (method === 'OPTIONS') {\n      return handleOptions(origin, allowedOrigins);\n    }\n\n    try {\n      // Route: /session\n      if (path === '/session') {\n        return handleSession(request, env, origin, allowedOrigins);\n      }\n\n      // Route: /analyze (AI only, no storage)\n      if (path === '/analyze' && method === 'POST') {\n        return analyzeAura(request, env, origin, allowedOrigins);\n      }\n\n      // Route: /aura (create with storage - legacy)\n      if (path === '/aura' && method === 'POST') {\n        return handleAura(request, env, origin, allowedOrigins);\n      }\n\n      // Route: /aura/:id (get)\n      const auraMatch = path.match(/^\\/aura\\/([a-zA-Z0-9_-]+)$/);\n      if (auraMatch && method === 'GET') {\n        return handleAura(request, env, origin, allowedOrigins, auraMatch[1]);\n      }\n\n      // Route: /image/:key (serve images from R2)\n      const imageMatch = path.match(/^\\/image\\/(.+)$/);\n      if (imageMatch && method === 'GET') {\n        return handleImage(env.IMAGES, imageMatch[1]);\n      }\n\n      // Route: /credits (TODO: implement in Phase 4)\n      if (path === '/credits') {\n        return errorResponse('Not implemented', origin, allowedOrigins, 501);\n      }\n\n      // Route: /webhook/stripe (TODO: implement in Phase 4)\n      if (path === '/webhook/stripe') {\n        return errorResponse('Not implemented', origin, allowedOrigins, 501);\n      }\n\n      // 404 for unknown routes\n      return errorResponse('Not found', origin, allowedOrigins, 404);\n\n    } catch (error) {\n      console.error('Unhandled error:', error);\n      return errorResponse('Internal server error', origin, allowedOrigins, 500);\n    }\n  },\n};\n\n// Serve images from R2\nasync function handleImage(r2: R2Bucket, key: string): Promise<Response> {\n  const object = await r2.get(key);\n\n  if (!object) {\n    return new Response('Image not found', { status: 404 });\n  }\n\n  const headers = new Headers();\n  headers.set('Content-Type', object.httpMetadata?.contentType || 'image/jpeg');\n  headers.set('Cache-Control', 'public, max-age=31536000');\n  headers.set('Access-Control-Allow-Origin', '*');\n\n  return new Response(object.body, { headers });\n}\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/.wrangler/tmp/bundle-a1UsWK/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/.wrangler/tmp/bundle-a1UsWK/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/jans./Downloads/aura-canvas_-ai-image-editor/worker-api/.wrangler/tmp/bundle-a1UsWK/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
